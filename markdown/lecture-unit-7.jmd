# Unit 7: Working with heterogenous datasets and a view towards machine learning

In this unit we learn how to deal with heterogenous datasets using data frames. We then explore basic concepts of machine learning. A deep dive into deep learning at UQ is in the [STAT3007 course](https://my.uq.edu.au/programs-courses/course.html?course_code=STAT3007). Theory of machine learning (and statistical learning) is also studied in [STAT3006](https://my.uq.edu.au/programs-courses/course.html?course_code=STAT3006). Other aspects of applied statistics and data analysis are studied in [STAT3500](https://my.uq.edu.au/programs-courses/course.html?course_code=STAT3500). Our purpose with this unit is just to touch the tip of the iceberg on issues of data analysis and machine learning. The Julia language knowledge acquired in the previous units should help.

# Databases

This course doesn't touch databases, a rich topic of its own. (Do not confuse the term database with data structures or data frames). A database is a system that stores information in an organized and flexible manner. Many databases are **relational databases** and this means that they are comprised of multiple data tables that are associated via relations. The most common language for dealing with such databases is [SQL](https://en.wikipedia.org/wiki/SQL). It is not a general programming language but rather a language for querying, modifying, and managing databases. At UQ you can study more about databases in the [INFS2200 course](https://my.uq.edu.au/programs-courses/course.html?course_code=infs2200) as well as several other more advanced courses. 

We now show you an example of database and a few things you may expect from SQL.


# Dataframes

Working with tabular data is a central part of data analysis (think Excel). Data has rows (observations) and columns (variables/features). Typically a row would be for an individual, or item, or event. Typically a column would be for attributes of the individual, properties of the events, etc. Variables can be numerical, categorical, strings, or even more complex entities (e.g. images).

The datafile `athlete_events.csv` is a moderately sized dataset available from [Kaggle](https://www.kaggle.com/heesoo37/120-years-of-olympic-history-athletes-and-results) covering all athletes that have participated the Summer or Winter Olympics between 1896 and 2016. The CSV file contains 40MB of data over 15 columns and more than 27,000 rows, which is "small data" for a modern computer (but would have been challenging in the 1980's). In this context, "big data" is too large to be handled by a single machine, and we'll discuss "big data" and "medium data" later.

You have already seen how to read and write from CSV files in Unit 3 where you also explored JSON files. You may recall using the `DataFrames.jl` package in that unit. We now take a deeper dive into the concept of dataframes.

We will use `athlete_events.csv` to show basic functionality of the [DataFrames.jl](https://dataframes.juliadata.org/stable/) and [TypedTables.jl](https://github.com/JuliaData/TypedTables.jl) packages. In a sense these packages are alternatives. Seeing some functionality from each may be useful for gaining a general understanding of what to expect from such packages. If you work with Python, then using [pandas](https://pandas.pydata.org/) is the common alternative. Similarly if you work with the R language then the built-in dataframes are common.

## Basic data exploration

Whenever you receive a dataset, it takes some time to understand its contents. This process is generally known as "data exploration". To do so, we generally load (a subset of) the data from disk and do some basic analysis in a Jupyter notebook or at the REPL.

```julia
using DataFrames, CSV
csv_file = CSV.File("../data/athlete_events.csv"; missingstring = "NA")
df = DataFrame(csv_file)
println("Data size: ", size(df))
println("Columns in the data: ", names(df))
```

Since the data is large, we don't usually want to print it all. The `first` and `last` functions can be helpful:

```julia
first(df, 10)
```

```julia
last(df, 10)
```

This dataset appears to be sorted by last name. Each row corresponds to an entrant to an event. The ID column identifies each unique athlete.

A `DataFrame` is indexed like a 2D container of rows and columns. The `:` symbol means "all".

```julia
df[1:10, :]
```

Internally, a dataframe stores one vector of data per column. You can access any of them conveniently as "properties" with `.` syntax:

```julia
df.ID
```

```julia
df.Height
```

As you can see from above, some data can be missing. How many heights are missing?

```julia
ismissing.(df.Height) |> count # Piping: `f(x) |> g` syntax means `g(f(x))`
```

The `count` function counts the number of `true` values.

How many unique athletes are there?

```julia
unique(df.ID) |> length
```

The `unique` operation has extra methods defined for `DataFrame`s. We can get the athlete data like so:

```julia
athlete_df = unique(df, :ID)
```

It keeps all columns of the first row containing each distinct ID, which will we take as representative (for their Sex, Height, Weight, etc).

## Simple analysis

Now we are becoming familiar with the dataset, we might like to see what insights we can gain. For example, let's see how many men and women have competed.

```julia
count(==("M"), athlete_df.Sex)  # `==(x)` creates a function `y -> y == x`
```

```julia
count(==("F"), athlete_df.Sex)
```

The `count` function is useful, but this gets tiresome for many "groups" of data. The [SplitApplyCombine.jl](https://github.com/JuliaData/SplitApplyCombine.jl) package contains useful functions for grouping data.

```julia
using SplitApplyCombine

groupcount(athlete_df.Sex)
```

Which allows us to explore at other groupings

```julia
# How many athletes by country
team_sizes = groupcount(athlete_df.Team)
```
One of the most powerful tricks in data analysis is to sort your data.

```julia
sort(team_sizes)
```

Note that `groupcount` is a specialization of the more flexible `group(keys, values)` function:

```julia
group(athlete_df.Team, athlete_df.Name)
```

Rather than acting at the level of vectors, you can group an entire `DataFrame` into a `GroupedDataFrame` with the `groupby` function provided by *DataFrames.jl*:

```julia
gdf = groupby(athlete_df, :Team)
```

You can apply an operation to each group and bring the data together into a single `DataFrame` via the `combine` function.

```julia
combine(gdf, nrow => :Count)
```

The `nrow => :Count` syntax is a convenience provided by *Dataframes.jl*. We'll explain how it works below.

## Manipulating DataFrames

Now go through all the things you can do with dataframes.

## More analysis

Create some plots to analyze some trends

 * Mean athlete height by year.
 * Gender statistics? E.g. most successful women's teams?
 * Country success vs time.
 * A table to join with would be good. Perhaps country statistics? Show correlation between population vs gold medals, GDP vs gold medals, etc.

Emphasis on plots.

## Notes

* QQQQ - Get dataset:
- Not too many rows, not too little.
- 3-5 correlated variables.  
- Categorical
- Missing
- Two datasets for join

* Beyond arrays, dictionaries, and such... but not yet in a DB.
* The dataframes package/typedtables.jl - basic usage:
 - Filtering rows.
 - Accessing.
 - Modifying.
 - Copy, DeepCopy, etc....
* Spliting, apply, and `by()`
* Join... 
* Missing values and basic imputation.

* EDA (Exploratory data analysis) StatsPlots.jl

# Memory management

* More on the heap vs. stack. 
* The garbage collector.
* Out-of-core example - working/fetching files.... (DataFrames works with "arrow format" (https://en.wikipedia.org/wiki/Apache_Arrow). Example that implements line by line CSV... and then discuss modern paradigms such as Arrow

# ML Datasets

There are some datasets used in machine learning learning, exploration, and (sometimes) practice that are very popular. This [YouTube video](https://www.youtube.com/watch?v=jrtxL5JHpTk) overviews a few such datasets. 

One of the most common datasets is the [MNIST Digits dataset](https://en.wikipedia.org/wiki/MNIST_database). It is composed of monochrome digits of $28 \times 28$ pixels and **labels** indicating each digit. There are $60,000$ digits that are called the **training set** and $10,000$ additional digits that are called the **test set**. In Julia you can access this dataset via the `MLDatasets.jl` package.


```julia
using MLDatasets
train_data = MLDatasets.MNIST.traindata(Float64)

imgs = train_data[1]
@show typeof(imgs)
@show size(imgs)

labels = train_data[2]
@show typeof(labels);
```

```julia
test_data = MLDatasets.MNIST.testdata(Float64)
test_imgs = test_data[1]
test_labels = test_data[2]
@show size(test_imgs);
```

```julia
n_train, n_test = length(labels), length(test_labels)
```

```julia
using Plots
println("The first 12 digits: ", labels[1:12])
plot([heatmap(train_data[1][:,:,k]',
            yflip=true,legend=false,c=cgrad([:black, :white])) for k in 1:12]...)
```
It is sometimes useful to "compact" each image into a vector. This then yields a matrix of $60,000 \times 784$ (each image has $784$ features since $784 = 28 \times 28$. We can plot that matrix as well.

```julia
X = vcat([vec(imgs[:,:,k])' for k in 1:last(size(imgs))]...)
@show size(X)
heatmap(X,legend=false)
```

# Unsupervised learning

In general, **unsupervised learning** is the process of learning attributes of the data based only on relationships between features (pixels in the the context of images) and not based on data labels $Y$. So in unsupervised learning we only have $X$.

One type of unsupervised learning focusing on **data reduction** is **principal component analysis (PCA)**. Here the data is projected from a 784 dimensional space into a smaller dimension of our choice. So for example if we choose the smaller dimension to be $2$ then we can "plot" each data point on this new plane. Doing so and comparing some of the digits we can get a feel for how PCA can be useful.

```julia
using MultivariateStats
pca = fit(PCA, X'; maxoutdim=2)
M = projection(pca)

args = (ms=0.8, msw=0, xlims=(-5,12.5), ylims=(-7.5,7.5),
            legend = :topright, xlabel="PC 1", ylabel="PC 2")

function compareDigits(dA,dB)
    xA = X[labels .== dA, :]'
    xB = X[labels .== dB, :]'
    zA, zB = M'*xA, M'*xB
    
    scatter(zA[1,:], zA[2,:], c=:red, label="Digit $(dA)"; args...)
    scatter!(zB[1,:], zB[2,:], c=:blue, label="Digit $(dB)"; args...)
end

plots = []
for k in 1:5
    push!(plots,compareDigits(2k-2,2k-1))
end
plot(plots...,size = (800, 500), margin = 5mm)
```

Another common form of unsupervised learning is **clustering**. The goal of clustering is to find data samples that are homogenous and group them together. Within such group (or cluster) you can also find a representative data point or an average of data points in the group. This is sometimes called a **centroid** or **centre**. The most basic clustering algorithm is $k$-means. It operates by iterating the search of the centres of clusters and the data points that are in the cluster. The parameter $k$ is given before hand as the number of clusters. 

Here we use the `Clustering.jl` package to apply $k$-means to MNIST. We then plot the resulting centroids. 

```julia
using Clustering, Random
Random.seed!(0)
clusterResult = kmeans(X',10)
heatmap(hcat([reshape(clusterResult.centers[:,k],28,28)' for k in 1:10]...),
    yflip=true,legend=false,aspectratio = 1,ticks=false,c=cgrad([:black, :white]))
```

# Supervised learning

A much more common form of machine learning is **supervised learning** where the data is comprised of the features (or independent variables) $X$ and the labels (or dependent variables or response varibles) $Y$. 

In cases where the variable to be predicted, $Y$, is a continuos or numerical variable, the problem is typically called a **regression problem**. Otherwise, in cases where $Y$ comes from some finite set of label values the problem is called a **classification problem**. For example in the case of MNIST digits, it is a classification problem since we need to look at an image and determine the respective digit.

## A taste of deep learning

Before we deal with a few basic introductory methods, let us get a glimpse of methods that are near the current "state of the art". These are generally **deep learning** methods which are based on multi-layer (deep) neural networks. See for example the material in the course, [The Mathematical Engineering of Deep Learning](https://deeplearningmath.org/index.html) as well as linked material from there.

To demonstrate we use the package `Metalhead.jl` which supplies "out of the box" deep learning models ready to use. The VGG deep convolutional neural network architecture is one classic model. 

This code downloads the pre-trained VGG19 model which is about 0.5Gb (!!!) of data. It then prints the layers of this deep neural network.

```julia
using Metalhead

#downloads about 0.5Gb of a pretrained neural network from the web
vgg = VGG19();
vgg = VGG19();
for (i,layer) in enumerate(vgg.layers)
    println(i,":\t", layer)
end
```

We don't cover the meaning of such a model in this course. See for example [this AMSI summer school course](https://deeplearningmath.org/) or the [UQ course on deep learning](https://www.nan-ye.com/teach/stat4402/). But we can use this pretrained model.

```julia
#download an arbitrary image and try to classify it
download("https://deeplearningmath.org/data/images/appleFruit.jpg","appleFruit.jpg");
img = load("appleFruit.jpg")
```

```julia
classify(vgg,img)
```

The image is actually not of "Granny Smith" apple, but rather a different type of apple. Still it is pretty close! VGG19 was trained on the famous [Image net database](https://www.image-net.org/).

## The basics: linear models

We don't have time in this course to get into the full details of deep learning. But we can start with a (degenerate) neural network - a linear model.

```julia
using LinearAlgebra
using Flux: onehotbatch

A = [ones(n_train) X]
Adag = pinv(A)  
tfPM(x) = x ? +1 : -1
yDat(k) = tfPM.(onehotbatch(labels,0:9)'[:,k+1])
bets = [Adag*yDat(k) for k in 0:9]

linear_classify(square_image) = findmax([([1 ; vec(square_image)])'*bets[k] for k in 1:10])[2]-1
```

```julia
predictions = [linear_classify(test_imgs[:,:,k]) for k in 1:n_test]
confusionMatrix = [sum((predictions .== i) .& (test_labels .== j)) for i in 0:9, j in 0:9]
acc = sum(diag(confusionMatrix))/n_test

println("Accuracy: ", acc, "\nConfusion Matrix:")
show(stdout, "text/plain", confusionMatrix)
```

## Getting a feel for gradient based learning



```julia
using Random, Distributions, Plots, Measures, LaTeXStrings
Random.seed!(1)

n = 10^3
beta0, beta1, sigma = 2.0, 1.5, 2.5
eta = 10^-3

xVals = rand(0:0.01:5,n)
yVals = beta0 .+ beta1*xVals + rand(Normal(0,sigma),n)

pts, b = [], [0, 0]
push!(pts,b)
for k in 1:10^4
    i = rand(1:n)
    g = [   2(b[1] + b[2]*xVals[i]-yVals[i]),
            2*xVals[i]*(b[1] + b[2]*xVals[i]-yVals[i])  ]
    global b -= eta*g
    push!(pts,b)
end

p1 = plot(first.(pts),last.(pts), c=:black,lw=0.5,label="SGD path")
     scatter!([b[1]],[b[2]],c=:blue,ms=5,label="SGD")
     scatter!([beta0],[beta1],
        c=:red,ms=5,label="Actual",
        xlabel=L"\beta_0", ylabel=L"\beta_1",
        ratio=:equal, xlims=(0,2.5), ylims=(0,2.5))

p2 = scatter(xVals,yVals, c=:black, ms=1, label="Data points")
     plot!([0,5],[b[1],b[1]+5b[2]], c=:blue,label="SGD")
     plot!([0,5],[beta0,beta0+5*beta1],	c=:red, label="Actual",
            xlims=(0,5), ylims=(-5,15), xlabel = "x", ylabel = "y")

plot(p1, p2, legend=:topleft, size=(800, 400), margin = 5mm)
```


# Tree based models 

* Hand made decision tree on simple dataset.
* Decision trees
* Boosting 
* Random forests

# Tips for implementing random forests.


