# Homework \#1 - Semester 2, 2021

--- 

## Question 1: LaTeX, Jupyter, HTML, and Markdown

This question deals with basic formatting tools.

**1a**: Consider the following continued fraction formula for the golden ratio $\varphi$:

$$
\varphi=1+\frac{1}{1+\frac{1}{1+\ddots}}
$$

Use LaTeX to write a version of it with two additional nested levels. That is, replace the '$\ddots$' with two additional levels. 

**1b**: Use Markdown to write an ordered list of your 5 favorite books. Add (Markdown) hyperlinks to each of the books.

**1c**: Use HTML to embed an image with an hyperlink from the image. Use HTML to resize the image to a size you like. Make sure the aspect ratio is maintained.

**1d**: Use HTML to create a table of your weekly class schedule. See for example this [reference](https://www.w3schools.com/html/html_tables.asp).



## Question 2: Continued Fractions for the Golden Ratio

In this question we deal wit the [golden ratio](https://en.wikipedia.org/wiki/Golden_ratio),
$$
\varphi = \frac{\sqrt{5}+1}{2}.
$$

It naturally appears as the solution of a quadratic equation but can also be represented via a continued fraction as in Question 1. 

Consider the code below which initilizes the continued fraction expression with an 'initial guess' of $2$.

```julia
function golden_continued_frac(n, init = 2)
    φ = init # \varphi + [TAB]
    for _ in 1:n
        φ = 1+1/φ
    end
    φ
end

golden_explicit = (√5+1)/2
@show golden_explicit

for n in 1:5
    println("n=$n\tapprox = ", golden_continued_frac(n))
end
```

**2a**: Explain why (prove) that if we set `init=(√5+1)/2` then the approximation is exact. I.e, why does the following output occur?

```julia
for n in 1:5
    println("n=$n\tapprox = ", golden_continued_frac(n, golden_explicit))
end
```

**2b**: It is thus expected that error of the approximation will depend on how far the initial value is from the actual golden ratio, as well as on the number of levels of the continued fraction. Investigate this error for initial values in the range of $\pm 0.5$ with steps of $0.1$ from the golden ratio and $n=5,6,7,8,9,10$.

**Solution**:

```julia
using Plots

init_grid = (golden_explicit-0.2):0.05:(golden_explicit+0.2)
n_range = 5:10
results = Dict()
for init in init_grid, n in n_range
    results[(init, n)] = abs(golden_continued_frac(n,init) - golden_explicit)
end

plot(n_range, 
    [results[(init,n)] for n in n_range, init in init_grid],
    label=round.(hcat(init_grid...) .- golden_explicit,digits=2),
    xlabel = "n",
    ylabel = "Absolute error")
```


## Question 3: Primes and Goldbach's conjecture

[Goldbach's conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture) states that every even number greater than two can be represented as a sum of two primes. For example $16 = 11+5$ and $40 = 37+3$ or $23+17$. In this question you will try to disprove the conjecture by searching for an even number that is not a sum of two primes (don't expect to succeed in disproving).

First consider the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) implemented as follows:

```julia
"""
Returns the first `n` primes.
"""
function sieve_of_Eratosthenes(n)
    primebits = ones(Bool,n) #Will contain true if the index is prime (initially all assumed prime)
    primebits[1] = false #The number 1 is not prime
    p = 2 #Smallest prime
    while p ≤ n
        i = 2p
        while i ≤ n  # \le +[TAB]
            primebits[i] = false
            i += p
        end
        p += 1
        while p ≤ n && !primebits[p]
            p += 1
        end
    end
    (1:n)[primebits]
end

n = 100
println("First $n primes: ",sieve_of_Eratosthenes(n))
```

This sieve yields a way to get a list of the first $n$ primes. However it is used inefficiently in the code below to create a plot of the number of pairs


```julia
using Plots
function check_Goldbach(n)
    @assert iseven(n)
    num_pairs = 0
    for p in sieve_of_Eratosthenes(n)
        if in(n-p,sieve_of_Eratosthenes(n))
            num_pairs += 1
        end
    end
    return num_pairs
end

n = 10^3
even_range = 4:2:n
checks = check_Goldbach.(even_range)
if 0 ∈ checks
    println("Found a counter example for Goldbach")
end
scatter(even_range,checks,legend=false,xlabel="n",ylabel="Number of Goldbach pairs")
```

## Question 4: Binary, Hex, Decimal, and BCD 

```julia

```

## Question 5 - Sorting - Part 1


```julia
function array_table(array, heading)
    println(heading,":")
    for (i,a) in enumerate(array)
        println(i,"\t",a)
    end
end

names = [   "Amy Chan",
            "Maithili Mehta",
            "Anna Foeglein",
            "Andy Ferris",
            "Thomas Graham",
            "Elaine Schenk",
            "Jesse Woods",
            "Tina Moghaddam",
            "Paul Bellette",
            "Paul Vrbik",
            "Yoni Nazarathy"]

sorted_names = sort(names)
array_table(sorted_names, "Sorted by first name")

println()

sorted_names = sort(names,by=(x)->reverse(split(x," ")))
array_table(sorted_names,"Sorted by last name")
```


## Question 6 - Sorting - Part 2


Quick sort analysis was in class. We now analyze merge-sort (for the number of comparisons).



## Question 7 - Matrix Multiplication

```julia
using LinearAlgebra, Plots

function a_mat(K,γ)
    A = diagm(fill(1+2γ,K)) + diagm(+1 => fill(1-γ,K-1)) + diagm(-1 => fill(1-γ,K-1))
    A[1,1] = 1+γ
    A[K,K] = 1+γ
    A[1,K] = 1
    A[K,1] = 1
    A
end

function ã_mat(K,γ)
     el(i,j,K) = (i^2 - i + (K+1-j)^2 - (K+1-j) ) / (2K*γ) - (K^3 - K - 6γ)/(6(K^2)*γ)
     [i ≤ j ? el(i,j,K-1) : el(j,i,K-1) for i in 1:K, j in 1:K]
end 
A = a_mat(10,0.5)
Ã = ã_mat(10,0.5)
A
#pA = heatmap(A,yflip=true,aspect=1,legned=false)
#pÃ = heatmap(Ã,yflip=true,legned=false)

#plot(pA,pÃ,legend=false)
```

```julia
Ã
```

```julia
inv(A)
```

```julia
Ã-inv(A)
```


```julia
function my_mat_multiply(A, B; method = :inner)
    nA,mA = size(A)
    nB,mB = size(B)
    @assert mA == nB
    n,m,p = nA,mA,mB
    C = Array{Float64}(undef,n,p)
    if method == :inner
        for i in 1:n
            for j in 1:p
                C[i,j] = A[i,:]'*B[:,j]
            end
        end
    elseif method == :cols
        for i in 1:p
            C[:,i] = sum([A[:,i]*B[i,j] for j in 1:m])
        end
    elseif method == :rows
        for i in 1:p
            C[:,i] = sum([A[:,i]*B[i,j] for j in 1:m])
        end
    elseif method == :outer
        for i in 1:p
            C[:,i] = sum([A[:,i]*B[i,j] for j in 1:m])
        end
    end
    C
end

Atest = [1 2 3; 4 5 6]
Btest = [1 2 3 4; 5 6 7 8; 9 10 11 12]

my_mat_multiply(Atest,Btest,method = :cols)
```

```julia
Atest*Btest
```

## Question 8 - Recursive Computation of Determinants
